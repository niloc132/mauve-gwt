This is Mauve, a free test suite for the Java Class Libraries.

Mauve is intended to test several different varieties of the
libraries.  For instance, it will contain tests that are specific to a
particular JDK version.  Tags in the test files help the test
framework decide which tests should or should not be run against a
given runtime.


To build, first run configure.  You can control the configuration with
some environment variables:

     JAVA   Name of Java interpreter to use
     JAVAC  Name of Java (to class) compiler to use
     GCJ    Name of Java (to object) compiler to use

GCJ is only used when the `--with-gcj' option is given to configure.

Use `make check' to run the tests.  You can set the make variable
`KEYS' to select a subset of the tests.  KEYS is a list of keys that
must be matched by the files to be tested.  Some values:

     * Any key starting with `java.' is taken to be the name of a
       class hierarchy.
       E.g., the key `java.lang' matches only test classes in java.lang.*.
       If multiple keys of this type, a test file need only match one
       to be included.

     JDK1.0  Run JDK1.0 tests only
     JDK1.1  Run JDK1.1 tests only
     JDK1.2  Run JDK1.2 tests only

You can use `make recheck' to re-run `make check' with the key list
you last used.


================================================================

Tags in a test are specified a little differently from tags on the
command line.

Each tag on the command line is first mapped to a list of actual tags.
E.g., "JDK1.2" implies all the tags "JDK1.0", "JDK1.1", and "JDK1.2".

If any tag from the expanded list is matched by the test case, then
the test case is chosen.

However, if one of the tags specified on the command line appears in
the test with a `!' prefix, then the test is rejected.

Tags must all appear on a single line beginning "// Tags: ".

Many files test functionality that has existed since JDK1.0.  The
corresponding line in the source:

    // Tags: JDK1.0

Here is how you would tag something that first appeared in JDK1.2:

    // Tags: JDK1.2

Here is how you would tag something that was eliminated in JDK1.2:

    // Tags: JDK1.0 !JDK1.2

The idea behind this scheme is that it is undesirable to update all
the files whenever we add a tag.  So instead most tags are defined in
terms of primitive tags, and then we note the exceptions.

When adding a new tag, change the `choose' program to map the
specified tag onto the implied tags.  There is some code near the top
that handles this transformation.
